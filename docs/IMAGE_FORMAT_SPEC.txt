================================================================================
SSD1306 PAGE FORMAT SPECIFICATION
================================================================================

This document describes the page-first format required by the SSD1306 display
and how to convert images from common formats to this format.

================================================================================
SSD1306 PAGE-FIRST FORMAT (Required Format)
================================================================================

FORMAT OVERVIEW:
----------------
- Data is organized BY PAGES, then BY COLUMNS
- Each byte contains 8 VERTICAL pixels (one column, one page)
- Format: data[page * width + column]

ATARI IMAGE EXAMPLE (120×64 pixels):
------------------------------------
Dimensions: 120 pixels wide × 64 pixels tall
Total bytes: 960 bytes (120 columns × 8 pages)

Organization:
  Page 0 (rows 0-7):    bytes 0-119   (columns 0-119)
  Page 1 (rows 8-15):   bytes 120-239 (columns 0-119)
  Page 2 (rows 16-23):  bytes 240-359 (columns 0-119)
  Page 3 (rows 24-31):  bytes 360-479 (columns 0-119)
  Page 4 (rows 32-39): bytes 480-599 (columns 0-119)
  Page 5 (rows 40-47):  bytes 600-719 (columns 0-119)
  Page 6 (rows 48-55):  bytes 720-839 (columns 0-119)
  Page 7 (rows 56-63):  bytes 840-959 (columns 0-119)

Byte index formula: index = page * width + column

BYTE FORMAT (Inside Each Byte):
-------------------------------
Each byte represents 8 vertical pixels in one column of one page:

  Bit 0 (LSB) = top pixel    (e.g., row 0, 8, 16, 24, 32, 40, 48, 56)
  Bit 1       = pixel below  (e.g., row 1, 9, 17, 25, 33, 41, 49, 57)
  Bit 2       = pixel below  (e.g., row 2, 10, 18, 26, 34, 42, 50, 58)
  Bit 3       = pixel below  (e.g., row 3, 11, 19, 27, 35, 43, 51, 59)
  Bit 4       = pixel below  (e.g., row 4, 12, 20, 28, 36, 44, 52, 60)
  Bit 5       = pixel below  (e.g., row 5, 13, 21, 29, 37, 45, 53, 61)
  Bit 6       = pixel below  (e.g., row 6, 14, 22, 30, 38, 46, 54, 62)
  Bit 7 (MSB) = bottom pixel (e.g., row 7, 15, 23, 31, 39, 47, 55, 63)

  Value: 1 = pixel ON (white), 0 = pixel OFF (black)

================================================================================
CONVERSION FROM ROW-FIRST FORMAT
================================================================================

SOURCE FORMAT: "Horizontal 1 bit per pixel plain bytes" (Row-First)
--------------------------------------------------------------------
- Each byte contains 8 HORIZONTAL pixels
- Data is organized by rows: [row0_byte0...row0_byteN, row1_byte0...row1_byteN, ...]
- For 120 pixels wide: 15 bytes per row (120 pixels / 8 = 15 bytes)
- For 64 rows: 64 × 15 = 960 bytes total

CONVERSION PROCESS:
-------------------
To convert from row-first to page-first format:

1. For each pixel column (0 to 119):
   a. For each page (0 to 7):
      - Extract the bit from each of the 8 rows in that page
      - Pack into one byte: bit 0 = top row, bit 7 = bottom row
      - Store at: page * 120 + column

2. Algorithm:
   For each page (0 to 7):
       For each pixel column (0 to 119):
           byte_val = 0
           For each bit (0 to 7):
               row = page * 8 + bit
               byte_idx_in_row = pixel_column // 8
               bit_in_byte = 7 - (pixel_column % 8)  # MSB first
               
               row_byte_idx = row * bytes_per_row + byte_idx_in_row
               source_byte = row_first_data[row_byte_idx]
               
               if source_byte & (1 << bit_in_byte):
                   byte_val |= (1 << bit)
           
           page_first_data[page * width + pixel_column] = byte_val

PYTHON CONVERSION SCRIPT:
-------------------------
The conversion script used in this project:

```python
width = 120
height = 64
bytes_per_row = width // 8  # 15 bytes per row

page_first = []
for page in range(8):  # 8 pages
    for pixel_col in range(120):  # 120 pixel columns
        byte_val = 0
        for bit in range(8):  # 8 bits (rows) per page
            row = page * 8 + bit
            if row < height:
                # Find which byte in the row contains this pixel
                byte_idx = pixel_col // 8
                bit_in_byte = 7 - (pixel_col % 8)  # MSB first
                
                row_byte_idx = row * bytes_per_row + byte_idx
                if row_byte_idx < len(raw_data):
                    if raw_data[row_byte_idx] & (1 << bit_in_byte):
                        byte_val |= (1 << bit)
        page_first.append(byte_val)
```

IMPORTANT NOTES:
----------------
1. The source data must be correctly encoded. If the bottom half appears
   shifted, the problem is in the source data encoding, not the conversion.

2. Color inversion: If your source image uses 0xFF for white and 0x00 for black,
   and you want white pixels on black background, you may need to invert the
   data. The final image data should have 1 bits for white pixels.

3. Padding: If source data is incomplete, pad with appropriate values
   (0x00 for black, 0xFF for white depending on your needs).

4. Verification: After conversion, verify:
   - Total bytes = width × (height / 8)
   - Page 0 contains rows 0-7
   - Page 7 contains rows 56-63
   - All columns are properly aligned

================================================================================
USAGE IN CODE
================================================================================

The converted data is stored in a header file (e.g., atari_mono2_page.h) and
used with the ssd1306_draw_page_image() function:

```c
#include "atari_mono2_page.h"

// Display the image (120x64)
ssd1306_draw_page_image(&display, atari_mono2_page, 
                        ATARI_MONO2_PAGE_WIDTH, 
                        ATARI_MONO2_PAGE_HEIGHT, 
                        x_offset, y_offset);
```

The drawing function expects data in page-first format and will display it
correctly without any additional transformations.

================================================================================
TROUBLESHOOTING
================================================================================

Problem: Bottom half of image is shifted
Solution: The issue is in the source data encoding, not the conversion or
          drawing function. Verify the source data is correctly formatted.

Problem: Image appears inverted (white/black swapped)
Solution: Invert the source data before conversion, or use ssd1306_invert()
          function (though it's better to have correctly inverted source data).

Problem: Image doesn't display at all
Solution: Verify:
          - Total byte count matches: width × (height / 8)
          - Data is in page-first format (not row-first)
          - Display initialization is correct

================================================================================
